#### 默认堆大小

- 1/4的物理内存做为最大堆内存
- 如果物理总内存小于1G，则会使用1/2的物理内存做为最大堆内存

#### 堆内存Xms Xmx建议设置成相同值

- 大内存具有蓄水池效应，降低GC频率

- 如果Xms一开始比较小，会导致一开始就频率GC，导致系统抖动
- 如果内存设置错误（如：超过可用大小），此时JVM可能无法启动，可以及时发现问题

#### 常用垃圾收集算法

- SerialGC
  - 适用于内存较小，CPU核心数较少（单核）的环境
  - 使用串行进行GC，停顿时间相对较久，吞吐量较低
  - 使用标记-复制的方式清理Young区
  - 使用标记-清除-整理的方式清理Old区

- ParallelGC
  - Java8默认使用的GC
  - 使用标记-复制的方式清理Young区
  - 使用标记-清除-整理的方式清理Old区
  - 触发GC会导致STW
  - 会使用多线程来进行GC，以提升吞吐量

- ConcMarkSweepGC
  - 使用标记-复制的方式清理Young区 （ParNew）
  - 使用标记-清除的方式清理Old区（CMS）
  - 标记-清除阶段可以和应用线程并发执行，减少应用线程的暂停，降低清理老年代的停顿时间
  - CMS会和应用线程竞争CPU资源，不适合在CPU密集型应用上使用（此时ParallelGC更适合）

- G1GC
  - 适用于堆内存比较大的（一般大于8G或16G），对低延迟有要求的
  - 从堆空间布局角度上看，把堆内存分割成了多块存放对象的小区域，其中Eden区、Survivor区、Old区都分布在这些块内
  - GC pause (G1 Evacuation Pause) (young)（疏散暂停：年轻模式）
  - 使用并发标记清理Old对象
  - 停顿时间过短，可能回导致G1回收垃圾太少，回收速度赶不上应用生产垃圾的速度，导致退化成串行的Full GC

#### 通过切换不同GC算法，打印GC日志发现

- 当内存比较大时，只触发了少量的Young区GC

- 适当的增大堆内存，减少Young区GC频率，Old区晋升频率，但是如果堆内存过大也会导致GC在做Major GC时，停顿时间过长

- 当开启自适应参数时，何时从Young区晋升到Old区并不固定，如果不开启自适应参数，则为经过15次Young GC后晋升

